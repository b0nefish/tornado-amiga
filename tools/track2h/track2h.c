/*
 * Converts a Rocket .track file to .h
 * Created by Miguel Mendez
 * This file is public domain.
 * Version 1.0 22 September 2018
 */

#include <ctype.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "track2h.h"

#define DATA_INTEGER 1
#define DATA_FLOAT 2
#define DATA_DOUBLE 3

// Interpolation functions from rocket.
static double key_linear(const struct track_key k[2], double row) {
  double t = (row - k[0].row) / (k[1].row - k[0].row);
  return k[0].value + (k[1].value - k[0].value) * t;
}

static double key_smooth(const struct track_key k[2], double row) {
  double t = (row - k[0].row) / (k[1].row - k[0].row);
  t = t * t * (3 - 2 * t);
  return k[0].value + (k[1].value - k[0].value) * t;
}

static double key_ramp(const struct track_key k[2], double row) {
  double t = (row - k[0].row) / (k[1].row - k[0].row);
  t = pow(t, 2.0);
  return k[0].value + (k[1].value - k[0].value) * t;
}

static void usage(char *progname) {

  fprintf(stderr,
          "Usage: %s -[ifd] -s <scale> -t <trackfile> -h <output file>\n",
          progname);
  fprintf(stderr, "-i : Emit integer values.\n");
  fprintf(stderr, "-f : Emit floating point values (defailt)\n");
  fprintf(stderr, "-d : Emit double values.\n");
  fprintf(stderr, "-s : Scaling factor.\n");
  fprintf(stderr, "-n : Do not interpolate. Instead generate an include file "
                  "with the key/value par structs.\n");
  exit(EXIT_FAILURE);
}

struct sync_track *loadTrackData(FILE *trackfile) {
  struct sync_track *track = calloc(1, sizeof(struct sync_track));
  fread(&track->num_keys, sizeof(int), 1, trackfile);
  track->keys = calloc(track->num_keys, sizeof(struct track_key));
  for (int i = 0; i < track->num_keys; i++) {
    char type;
    fread(&track->keys[i].row, sizeof(int), 1, trackfile);
    fread(&track->keys[i].value, sizeof(float), 1, trackfile);
    fread(&type, sizeof(char), 1, trackfile);
    track->keys[i].type = (enum key_type)type;
  }
  return track;
}

static void writeType(double data, double scale, int data_type, FILE *outfile) {
  switch (data_type) {
  case DATA_INTEGER:
    fprintf(outfile, "%i", (int)floor(data * scale));
    break;
  default:
    fprintf(outfile, "%f", data * scale);
    break;
  }
}

static char *dataName(char *fileName) {
  char *f = fileName;
  char c;
  while ((c = *f) != '\0') {
    if ((c == '.') || (c == '/')) {
      *f = '_';
    }
    f++;
  }
  return fileName;
}

void printHeader(int data_type, double scale, char *origin, FILE *outfile) {
  fprintf(outfile, "/*\n");
  fprintf(outfile, " * Generated by track2h. Source file: %s\n", origin);
  fprintf(outfile, " * Data output settings: ");
  switch (data_type) {
  case DATA_INTEGER:
    fprintf(outfile, "32bit Integer.\n");
    break;
  case DATA_FLOAT:
    fprintf(outfile, "Float.\n");
    break;
  case DATA_DOUBLE:
    fprintf(outfile, "Double.\n");
    break;
  }

  fprintf(outfile, " * Scale: %f\n", scale);
  fprintf(outfile, " */\n\n");

  char *guardName = strdup(origin);
  char *str = guardName;
  char c;
  while ((c = *str) != '\0') {
    if ((c == '/') || (c == '.')) {
      *str++ = '_';
    } else {
      *str++ = (char)toupper((int)c);
    }
  }
  fprintf(outfile, "#ifndef %s\n", guardName);
  fprintf(outfile, "#define %s\n\n", guardName);
}

void emitStructs(struct sync_track *track, char *dataName, FILE *outfile) {
  fprintf(outfile, "static struct rocket_track_key %s_keys[] = {\n", dataName);
  for (int i = 0; i < track->num_keys; i++) {
    fprintf(outfile, "{\n");
    fprintf(outfile, ".row = %i,\n", track->keys[i].row);
    fprintf(outfile, ".value = %f,\n", track->keys[i].value);
    fprintf(outfile, ".type = %i,\n", track->keys[i].type);
    fprintf(outfile, "}%s", i < (track->num_keys - 1) ? ",\n" : "\n");
  }
  fprintf(outfile, "};\n\n");

  fprintf(outfile, "struct rocket_sync_track %s = {\n", dataName);
  fprintf(outfile, ".name = \"%s\",\n", dataName);
  fprintf(outfile, ".keys = %s_keys,\n", dataName);
  fprintf(outfile, ".num_keys = %d,\n", track->num_keys);
  fprintf(outfile, "};\n\n");
  fprintf(outfile, "#endif\n");
}

void parseAndWrite(struct sync_track *track, int data_type, double scale,
                   char *dataName, FILE *outfile) {
  float f;
  struct track_key keyPair[2];

  switch (data_type) {
  case DATA_INTEGER:
    fprintf(outfile, "int ");
    break;
  case DATA_DOUBLE:
    fprintf(outfile, "double ");
    break;
  case DATA_FLOAT:
    fprintf(outfile, "float ");
    break;
  }

  fprintf(outfile, "%s[] = { ", dataName);

  int cursor = 0;
  for (int i = 0; i < (track->num_keys - 1); i++) {
    writeType(track->keys[i].value, scale, data_type, outfile);
    fprintf(outfile, ", ");
    cursor++;
    if (cursor > 9) {
      fprintf(outfile, "\n\t");
      cursor = 0;
    }

    keyPair[0].row = track->keys[i].row;
    keyPair[1].row = track->keys[i + 1].row;
    keyPair[0].value = track->keys[i].value;
    keyPair[1].value = track->keys[i + 1].value;

    for (int row = (track->keys[i].row + 1); row < track->keys[i + 1].row;
         row++) {
      switch (track->keys[i].type) {
      case KEY_STEP:
        writeType(track->keys[i].value, scale, data_type, outfile);
        break;
      case KEY_LINEAR:
        f = key_linear((const struct track_key *)&keyPair, (double)row);
        writeType(f, scale, data_type, outfile);
        break;
      case KEY_SMOOTH:
        f = key_smooth((const struct track_key *)&keyPair, (double)row);
        writeType(f, scale, data_type, outfile);
        break;
      case KEY_RAMP:
        f = key_ramp((const struct track_key *)&keyPair, (double)row);
        writeType(f, scale, data_type, outfile);
        break;
      default:
        break;
      }
      fprintf(outfile, ", ");
      cursor++;
      if (cursor > 9) {
        fprintf(outfile, "\n\t");
        cursor = 0;
      }
    }
  }
  writeType(track->keys[track->num_keys - 1].value, scale, data_type, outfile);
  fprintf(outfile, " };\n\n");
  fprintf(outfile, "#endif\n");
}

int main(int argc, char **argv) {
  int data_type = DATA_FLOAT;
  int ch;
  int interpolate = 1;
  char *name, *origin;
  FILE *trackfile, *outfile;
  struct sync_track *track;
  double scale = 1.0;

  if (argc < 5)
    usage(argv[0]);

  while ((ch = getopt(argc, argv, "nidft:h:s:")) != -1) {
    switch (ch) {
    case 'd':
      data_type = DATA_DOUBLE;
      break;
    case 'i':
      data_type = DATA_INTEGER;
      break;
    case 'f':
      data_type = DATA_FLOAT;
      break;
    case 'n':
      interpolate = 0;
      break;
    case 's':
      scale = atof(optarg);
      break;
    case 't':
      trackfile = fopen(optarg, "r");
      if (!trackfile) {
        fprintf(stderr, "FATAL - Cannot open <%s> for reading.\n", optarg);
        exit(EXIT_FAILURE);
      }
      origin = strdup(optarg);
      name = dataName(strdup(optarg));
      break;
    case 'h':
      outfile = fopen(optarg, "w");
      if (!outfile) {
        fprintf(stderr, "FATAL - Cannot open <%s> for writing.\n", optarg);
        exit(EXIT_FAILURE);
      }
      break;
    case '?':
    default:
      usage(argv[0]);
    }
  }
  argc -= optind;
  argv += optind;

  track = loadTrackData(trackfile);
  fclose(trackfile);

  printHeader(data_type, scale, origin, outfile);
  if (interpolate) {
    parseAndWrite(track, data_type, scale, name, outfile);
  } else {
    emitStructs(track, name, outfile);
  }

  fclose(outfile);
  exit(0);
}
